# Program 程序

## 概念

程序(Program) 是一组在cpu上执行的指令的集合。

这些集合叫做 机器码(machine code), 外在形式是 二进制指令(binary instructions)，俗称01代码。
内在形式 是cpu上的高低电平。

由三极管组成的门电路，由门电路组成的各种加法器，减法器，
乘法器等运算模块，再和芯片的外设共同组成了 Microcontrollers 或者 Processors。

模拟电路电子产品一旦被做出来，它的功能就确定了而不能改变。数字电路电子产品则不同，
可以给数字电路中的 Microcontrollers 烧写程序，而可以经由程序去改变产品的功能。

Processors 能且仅能接受的程序 是二进制指令(binary instructions)，是的，我们的程序员
一开始是用 二进制指令 编写程序的，二进制指令中 00 代表什么？ 01 代表什么？ 这些都在随芯片售卖的
用户手册上面写着有。这个世界上有许多芯片厂商，每家厂商有许多不同的型号的 Processor，
同系列的 Processor 支持的二进制指令集(binary instructions set)是相同的，否则是不同的 。

> [80x86 Opcodes](https://courses.engr.illinois.edu/ece390/resources/opcodes.html)
> 一份机器码和功能的对应表，可以打开看看，体会一下。

聪明的程序员发明了汇编器用来助记机器码的类英文单词(就是汇编语言)翻译成机器码，这样程序员就不用费脑
去记忆机器码了，何况每个芯片的机器码可能不太一样，记起来很辛苦。
汇编器本身就是一段程序，用这个程序可以将 由汇编代码 组成的文本文件(给人看的) 翻译成
机器码(给机器去执行的)。这是一个伟大的成就。

我们今天学习的C语言，就是在汇编语言上抽象了一个层次，C语言编译器，比如说GCC，它要编译C语言写的
文本文档时，就是先把C语言语句解释成汇编语句，再调用汇编器把汇编语句解释成机器码，生成最终程序文件。

C语言之所以可移植性好，是因为它的语言抽象层次高，另一个方面是它在各个平台之上都有C语言编译器。
这种高抽象语句随着不同平台的C语言编译器翻译成不同的二进制指令，却执行的是一个意思。
比如把某个变量+1,而程序员不关心芯片上是怎样做到的，这件事由 C语言编译器和它下游的汇编器 搞定了。

在操作系统还没出现的远古时期，跑在芯片上的程序是个爷们，权利很大，想干什么就干什么。操作系统之后之所以出现
是因为当时的硬件设备很贵，那些科学家想让硬件别空闲着，最好跑完一个程序接着跑另外一个，这就出现了
程序管理的思想。于是操作系统就出现了，最初的操作系统很简单，给程序排个队，让它们运行着吧。
可是人，人总是贪心的，老想着让操作系统做更多的事情。

排队就有优先级排序的问题，操作系统要去切换进程，就存在进程调度的问题，好几个程序共享一个系统资源，比如
占有cpu的时间，占用内存空间大小，访问有限的资源-打印机，这些就存在资源分配的问题。
一大堆的科学家就在那儿冥想，数学推论，讨论，发表论文，编写测试代码，终于做出几款不同的操作系统出来。

操作系统是一个服务者，是为应用程序服务的。
操作系统掌握着硬件资源，每当程序向操作系统调用资源时，操作系统就会作出回应。
如果把操作系统比作保姆，那么程序就像宝宝一样。
linux是一种多用户多任务分时操作系统，保姆会轮流去照顾多个宝宝(分时)，哭得厉害的先照顾(程序优先级)
响应宝宝的需求(系统调用)，为每个宝宝划定活动范围且互不干扰(程序之间相对独立内存空间)，
阻止宝宝做出伤害保姆，比如扣眼球，拉头发等行为(系统自我防护)，拒绝宝宝过分要求(请求不存在的资源).

